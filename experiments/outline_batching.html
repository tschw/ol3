<!doctype html>
<html>
    <head>
        <title>Outline Batching Experiment</title>
        <script src="http://ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
        <script src="http://ajax.googleapis.com/ajax/libs/jqueryui/1.10.3/jquery-ui.min.js"></script> 
        <link rel="stylesheet" href="http://code.jquery.com/ui/1.10.3/themes/smoothness/jquery-ui.css" />

        <script src="closure_base.js"></script>
        <script src="closure_mock.js"></script>

        <script src="webgl.js"></script>
        <script src="timer.js"></script>
        <script src="timeslicer.js"></script>

        <script src="outline_batching.js"></script>


<!--- Polygon Shaders -->


        <script id="webgl-poly-vert" type="x-shader/x-vertex">
#version 100

// ---- Configuration

precision mediump float;

// ---- Interface

attribute vec2 Position;
attribute float Control;

uniform mat2 Rotation;

varying vec2 Surface;
varying float Invalidator;

// ---- Implementation

float removeHighbits(float x, float valueOfLowest) {
    return x - floor(x / valueOfLowest) * valueOfLowest;
}
float extractHighbits(float x, float valueOfLowest) {
    return floor(x / valueOfLowest);
}

void main(void) {

    float edge = Control; 
    Surface = vec2(extractHighbits(edge, 4.), removeHighbits(edge, 4.));
    Invalidator = max(Surface.y - 2.0, 0.0);
    gl_Position = vec4(Rotation * Position, 0.0, 1.0);
}
        </script>

        <script id="webgl-poly-frag" type="x-shader/x-vertex">
// ---- Configuration

precision mediump float;

// ---- Interface

varying vec2 Surface;
varying float Invalidator;

uniform vec2 Scale;
uniform vec4 FillColor;
uniform vec4 StrokeColor;

uniform vec4 RenderParams;
float lineWidth = RenderParams.x;
float antiAliasing = RenderParams.y;
float gamma = RenderParams.z;
float rcpGamma = RenderParams.w;


// ---- Implementation

float blendCoeff(vec2 edge0, vec2 edge1, vec2 x) {
    vec2 weight = smoothstep(edge0, edge1, x);
    return max(weight.x, weight.y);
}

vec3 gammaApply(vec3 color) {
    return pow(abs(color), vec3(gamma));
}

vec3 gammaCorrect(vec3 color) {
    return pow(abs(color), vec3(rcpGamma));
}


void main(void) {

    if (Invalidator > 0.0) discard;

    // Determine distance vector from centerpoint (1;1) surface coordinates
    // the outer edge of the surface is located at 1
    vec2 dist = min(abs(Surface - vec2(1.0)), 1.0);

    // Determine surface scale from screen space derivatives
#ifdef STANDARD_DERIVATIVES
    vec2 dSurfPixX = dFdx(Surface), dSurfPixY = dFdy(Surface);
    vec2 scale = vec2(length(vec2(dSurfPixX.x, dSurfPixY.x)),
                      length(vec2(dSurfPixX.y, dSurfPixY.y)));
#else
    vec2 scale = Scale;
#endif

    // Determine surface coordinate thresholds:
    //
    // 0.0                                     1.0
    // ... inside.. - edge =#{ border }#= edge -|
    //              |<---+-->|<-------+-------->|  
    //              :   \|/  :       \|/        :
    //              :   /|\  :        |         :
    vec2 edgeWidth = antiAliasing * scale;
    //              :        :       /|\        :
    vec2 outline = lineWidth * scale;
    //              :        :        :         :
    //              :        :        ^<--------|
    vec2 outerEdgeMin = vec2(1.0) - edgeWidth;
    //              ^<-------:--------|
    vec2 innerEdgeMin = outerEdgeMin - outline;
    //              |--------^
    vec2 innerEdgeMax = innerEdgeMin + edgeWidth;
    // When these   ^^^^^^^^^^        ^^^^^^^^^^^ two regions
    // overlap, the maximum intensity will be below 1.
    //
    // Both regions have the same width and provide the input to
    // the same monotonic function (x=0 for region start).
    // 
    // => The result will never be blow zero, and
    // => there will be no jump discontinuities.
    // => maximum luminance at min(1.0, LineWidth / AntiAliasing)

    // Determine foreground color
    vec4 color = mix(FillColor, StrokeColor, blendCoeff(innerEdgeMin, innerEdgeMax, dist));

    // Adjust alpha for anti-aliasing on the outer edge
    color.a = color.a * (1.0 - blendCoeff(outerEdgeMin, vec2(1.0), dist));

    // Obviously - no implicit gamma correction happens on most platforms.
    // See: http://stackoverflow.com/questions/10843321
    //
    // This is only half of it - acutually the proper way would require
    // a finalizing rendering task, so that blending can be performed
    // in linearized color space.
    color.rgb = gammaCorrect(color.rgb);

#ifdef PREMULTIPLY_BY_ALPHA
    color.rgb *= color.a;
#endif
    gl_FragColor = color;
}
        </script>

<!--- Background Shaders -->

        <script id="webgl-bg-vert" type="x-shader/x-vertex">
#version 100

attribute vec2 Position;

void main(void) {
    gl_Position = vec4(Position, 0.0, 1.0);
}
        </script>
        <script id="webgl-bg-frag" type="x-shader/x-vertex">
#version 100
// ---- Configuration

precision mediump float;

// ---- Interface

uniform vec2 Offset;
uniform vec2 Scale;

// ---- Implementation

void main(void) {

    vec2 surf = fract((gl_FragCoord.xy - Offset) * Scale);

    float r = pow(distance(surf, vec2(1.0, 0.5)), 2.0) * 0.7;
    float g = pow(distance(surf, vec2(0.0, 1.0)), 2.0) * 0.7;
    float b = pow(distance(surf, vec2(0.0, 0.0)), 2.0) * 0.7;

    gl_FragColor = vec4(r, g, b, 1.0);
}
        </script>


        <style>
            body { margin: 0; }
            .invisible { display: none; }
            .error { border: 7px solid red; padding: 0px 10px; 
                     font-weight: bold; color: #600; }
            #webgl-canvas { float: left; }
            #user-interface { float: left; width: 320px; }
            .slider, .label, select { margin: 10px 10px 10px 20px; }
            .label { float: none; clear: left; } 
            .slider { float: left; width: 200px; }
            select { width: 300px; }
            .value-display { margin: 10px 10px 0px 0px; 
                             display: inline-block; float: right; }
        </style>
    </head>
    <body>

        <div id="app-panel">
            <canvas id="webgl-canvas" width="512" height="512"></canvas>
            <div id="user-interface">
                <select id="model" name="model">
                    <option value="0">Wide Line</option>
                    <option value="1">Wide Line Ring</option>
                    <option value="1">Wide Line and Ring multibatch</option>
                </select>
                <select id="program" name="program">
                    <option value="0">without extensions</option>
                </select>
                <div class="label">Rotation (rad,rad/s)</div>
                <div class="slider" id="rotation-angle"></div>
                <div class="slider" id="rotation-speed"></div>
                <div class="label">Line Width (pixels)</div>
                <div class="slider" id="line-width"></div>
                <div class="label">Anti Aliasing (pixels)</div>
                <div class="slider" id="anti-aliasing"></div>
                <div class="label">Gamma (of display)</div>
                <div class="slider" id="gamma"></div>
                <div class="label">Grid Size (pixels x,y)</div>
                <div class="slider" id="grid-size-x"></div>
                <div class="slider" id="grid-size-y"></div>
            </div>
        </div>

        <div id="webgl-unavailable" class="error invisible">
            <h3>This browser does not support WebGL!</h3>
            <p>
                See <a href="http://get.webgl.org">http://get.webgl.org</a> for information on updating
                or contact your system administrator.
            </p>
        </div>
        <div id="webgl-init-failed" class="error invisible">
            <h3> The initialization of WebGL failed.</h3>
            <p>
                See <a href="http://get.webgl.org/troubleshooting">http://get.webgl.org/troubleshooting</a> 
                for information on troubleshooting or contact your system administrator.
            </p>
        </div>
    </body>
</html>

