<!doctype html>
<html>
    <head>
        <title>Outline Batching Experiment</title>
        <script src="jquery-2.0.3.min.js"></script> 
        <script src="jqueryui-1.10.3.min.js"></script> 
        <link rel="stylesheet" href="jqui-theme/jquery-ui.css" />

        <script src="closure_base.js"></script>
        <script src="closure_mock.js"></script>

        <script src="libtess.cat.js"></script>

        <script src="webgl.js"></script>
        <script src="timer.js"></script>
        <script src="timeslicer.js"></script>
        <script src="geometry.js"></script>

        <script src="outline_batching_vs.js"></script>


<!--- Polygon Shaders -->


        <script id="webgl-poly-vert" type="x-shader/x-vertex">
#version 100

// ---- Configuration

precision mediump float;

// ---- Interface

attribute vec2 PositionP;
attribute vec2 Position0;
attribute vec2 PositionN;
attribute float Control;

attribute vec2 Style;
float lineWidth = Style.x;

uniform mat4 Transform;
uniform vec2 PixelScale;

varying vec2 v_Style;
varying vec2 Surface;
varying float Invalidator;
varying vec4 Color;

// ---- Implementation

float removeHighbits(float x, float valueOfLowest) {
    return x - floor(x / valueOfLowest) * valueOfLowest;
}
float extractHighbits(float x, float valueOfLowest) {
    return floor(x / valueOfLowest);
}

float zeroToOne(float f) {
    return f != 0.0 ? f : 1.0;
}

vec2 ccwNormal(vec2 p) { 
    return vec2(p.y, -p.x) / zeroToOne(length(p));
}

vec3 transform(vec2 p) {
    vec4 tmp = Transform * vec4(p, 0.0, 1.0);
    return tmp.xyz / tmp.w;
}

vec4 decodeRgb(float v) {
    float r = floor(v / 65536), g = floor(v / 256), b = floor(v);
    g -= b * 256;
    b -= r * 65536 + g * 256;
    return vec3(r,g,b);
}


void main(void) {

    // Apply transform
    vec2 pP = transform(PositionP).xy;
    vec2 p0 = transform(Position0).xy;
    vec2 pN = transform(PositionN).xy;

    // Look at two successive edges and determine direction / factor
    vec2 eP = ccwNormal(p0 - pP);
    vec2 eN = ccwNormal(pN - p0);
    vec2 normal = normalize(eP + eN);

    // Account for mitering
    float width = lineWidth / zeroToOne(dot(eN, normal));

    // Decode edge control value to surface coordinates
    vec2 surface = vec2(extractHighbits(Control, 4.0),
                        removeHighbits(Control, 4.0));

    // ...where a special value invalidates the vertex
    float invalidator = max(surface.y - 2.0, 0.0);

    // Sign of the locally horizontal surface coordinate
    // tells us whether to go left or right
    width *= zeroToOne(surface.x - 1.0);

    // Transform 
    vec4 vertex = Transform * vec4(Position0, 0.0, 1.0);
    vertex.xy += width * normal * PixelScale; 

    // Store varyings
    gl_Position = vertex;
    Surface = surface;
    Invalidator = invalidator;
    v_Style = Style;
}
        </script>

        <script id="webgl-poly-frag" type="x-shader/x-vertex">
// ---- Configuration

precision mediump float;

// ---- Interface

varying vec2 Surface;
varying float Invalidator;

varying vec2 v_Style;
float lineWidth = v_Style.x;
float outlineWidth = v_Style.y;

uniform vec2 Scale;
uniform vec4 FillColor;
uniform vec4 StrokeColor;

uniform vec3 RenderParams;
float antiAliasing = RenderParams.x;
float gamma = RenderParams.y;
float rcpGamma = RenderParams.z;


// ---- Implementation

float blendCoeff(vec2 edge0, vec2 edge1, vec2 x) {
    vec2 weight = smoothstep(edge0, edge1, x);
    return max(weight.x, weight.y);
}

vec3 gammaApply(vec3 color) {
    return pow(abs(color), vec3(gamma));
}

vec3 gammaCorrect(vec3 color) {
    return pow(abs(color), vec3(rcpGamma));
}

void main(void) {

    if (Invalidator > 0.0) discard;

    // Determine distance vector from centerpoint (1;1) surface coordinates
    // the outer edge of the surface is located at 1
    vec2 dist = min(abs(Surface - vec2(1.0)), 1.0);

    // Determine surface scale from screen space derivatives
#ifdef STANDARD_DERIVATIVES
    vec2 dSurfPixX = dFdx(Surface), dSurfPixY = dFdy(Surface);
    vec2 scale = vec2(length(vec2(dSurfPixX.x, dSurfPixY.x)),
                      length(vec2(dSurfPixX.y, dSurfPixY.y)));
#else
    vec2 scale = vec2(1.0 / lineWidth);
#endif

    // Determine surface coordinate thresholds:
    //
    // 0.0                                     1.0
    // ... inside.. - edge =#{ border }#= edge -|
    //              |<---+-->|<-------+-------->|  
    //              :   \|/  :       \|/        :
    //              :   /|\  :        |         :
    vec2 edgeWidth = antiAliasing * scale;
    //              :        :       /|\        :
    vec2 outline = outlineWidth * scale;
    //              :        :        :         :
    //              :        :        ^<--------|
    vec2 outerEdgeMin = vec2(1.0) - edgeWidth;
    //              ^<-------:--------|
    vec2 innerEdgeMin = outerEdgeMin - outline;
    //              |--------^
    vec2 innerEdgeMax = innerEdgeMin + edgeWidth;
    // When these   ^^^^^^^^^^        ^^^^^^^^^^^ two regions
    // overlap, the maximum intensity will be below 1.
    //
    // Both regions have the same width and provide the input to
    // the same monotonic function (x=0 for region start).
    // 
    // => The result will never be blow zero, and
    // => there will be no jump discontinuities.
    // => maximum luminance at min(1.0, LineWidth / AntiAliasing)

    // Determine foreground color
    vec4 color = mix(FillColor, StrokeColor, blendCoeff(innerEdgeMin, innerEdgeMax, dist));

    // Adjust alpha for anti-aliasing on the outer edge
    color.a = color.a * (1.0 - blendCoeff(outerEdgeMin, vec2(1.0), dist));

    // Obviously - no implicit gamma correction happens on most platforms.
    // See: http://stackoverflow.com/questions/10843321
    //
    // This is only half of it - acutually the proper way would require
    // a finalizing rendering task, so that blending can be performed
    // in linearized color space.
    color.rgb = gammaCorrect(color.rgb);

#ifdef PREMULTIPLY_BY_ALPHA
    color.rgb *= color.a;
#endif
    gl_FragColor = color;
}
        </script>

<!--- Background Shaders -->

        <script id="webgl-bg-vert" type="x-shader/x-vertex">
#version 100

attribute vec2 Position;

void main(void) {
    gl_Position = vec4(Position, 0.0, 1.0);
}
        </script>
        <script id="webgl-bg-frag" type="x-shader/x-vertex">
#version 100
// ---- Configuration

precision mediump float;

// ---- Interface

uniform vec2 Offset;
uniform vec2 Scale;

// ---- Implementation

void main(void) {

    vec2 surf = fract((gl_FragCoord.xy - Offset) * Scale);

    float r = pow(distance(surf, vec2(1.0, 0.5)), 2.0) * 0.7;
    float g = pow(distance(surf, vec2(0.0, 1.0)), 2.0) * 0.7;
    float b = pow(distance(surf, vec2(0.0, 0.0)), 2.0) * 0.7;

    gl_FragColor = vec4(r, g, b, 1.0);
}
        </script>


        <style>
            body { margin: 0; }
            .invisible { display: none; }
            .error { border: 7px solid red; padding: 0px 10px; 
                     font-weight: bold; color: #600; }
            #webgl-canvas { float: left; }
            #user-interface { float: left; width: 320px; }
            .slider, .label, select { margin: 10px 10px 10px 20px; }
            .label { float: none; clear: left; } 
            .slider { float: left; width: 200px; }
            select { width: 300px; }
            .value-display { margin: 10px 10px 0px 0px; 
                             display: inline-block; float: right; }
        </style>
    </head>
    <body>

        <div id="app-panel">
            <canvas id="webgl-canvas" width="512" height="512"></canvas>
            <div id="user-interface">
                <select id="model" name="model">
                    <option value="0">Wide Line</option>
                    <option value="1">Wide Line Ring</option>
                    <option value="2">Wide Line and Ring multibatch</option>
                    <option value="3">Single Triangle</option>
                    <option value="4">Manually Tesselated Triangle</option>
                    <!-- <option value="5">Auto-Tesselated Triangle</option> -->
                </select>
                <select id="program" name="program">
                    <option value="0">without extensions</option>
                </select>
                <div class="label">Rotation (rad,rad/s)</div>
                <div class="slider" id="rotation-angle"></div>
                <div class="slider" id="rotation-speed"></div>
                <div class="label">Scale (factor)</div>
                <div class="slider" id="scale-x"></div>
                <div class="slider" id="scale-y"></div>
                <div class="label">Line Width (pixels)</div>
                <div class="slider" id="line-width"></div>
                <div class="label">Outline Width (pixels)</div>
                <div class="slider" id="outline-width"></div>
                <div class="label">Anti Aliasing (pixels)</div>
                <div class="slider" id="anti-aliasing"></div>
                <div class="label">Gamma (of display)</div>
                <div class="slider" id="gamma"></div>
                <div class="label">Grid Size (pixels x,y)</div>
                <div class="slider" id="grid-size-x"></div>
                <div class="slider" id="grid-size-y"></div>
            </div>
        </div>

        <div id="webgl-unavailable" class="error invisible">
            <h3>This browser does not support WebGL!</h3>
            <p>
                See <a href="http://get.webgl.org">http://get.webgl.org</a> for information on updating
                or contact your system administrator.
            </p>
        </div>
        <div id="webgl-init-failed" class="error invisible">
            <h3> The initialization of WebGL failed.</h3>
            <p>
                See <a href="http://get.webgl.org/troubleshooting">http://get.webgl.org/troubleshooting</a> 
                for information on troubleshooting or contact your system administrator.
            </p>
        </div>
    </body>
</html>

