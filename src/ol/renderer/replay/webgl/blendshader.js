// This file is automatically generated, do not edit
goog.provide('ol.renderer.replay.webgl.BlendShader');
goog.require('ol.webgl.shader');
/**
 * @constructor
 * @extends {ol.webgl.shader.Fragment}
 * @param {WebGLRenderingContext} gl GL.
 */
ol.renderer.replay.webgl.BlendShaderFragment = function(gl) {
  goog.base(this,
    ol.renderer.replay.webgl.BlendShader.sourcePreamble_(gl) + ol.renderer.replay.webgl.BlendShaderFragment.SOURCE);
};
goog.inherits(ol.renderer.replay.webgl.BlendShaderFragment, ol.webgl.shader.Fragment);
/**
 * @const
 * @type {string}
 */
ol.renderer.replay.webgl.BlendShaderFragment.DEBUG_SOURCE =
    '//! NAMESPACE=ol.renderer.replay.webgl.BlendShader\n//! CLASS=ol.renderer.replay.webgl.BlendShader\n\n//! COMMON\n\nvarying vec2 TexCoord;\n\n\n//! FRAGMENT\n\nuniform float Opacity;\nuniform sampler2D Sampler0;\n\nvoid main(void) {\n\n    vec4 color = texture2D(Sampler0, TexCoord);\n    color.a *= Opacity;\n\n    const float invisible = 1. / 256.;\n    if (color.a < invisible) {\n      discard;\n    }\n    gl_FragColor = color;\n}\n\n';
/**
 * @const
 * @type {string}
 */
ol.renderer.replay.webgl.BlendShaderFragment.OPTIMIZED_SOURCE =
    'varying vec2 a;uniform float b;uniform sampler2D c;void main(){vec4 d=texture2D(c,a);d.a*=b;const float e=1./256.;if(d.a<e)discard;gl_FragColor=d;}';
/**
 * @const
 * @type {string}
 */
ol.renderer.replay.webgl.BlendShaderFragment.SOURCE = goog.DEBUG ?
    ol.renderer.replay.webgl.BlendShaderFragment.DEBUG_SOURCE :
    ol.renderer.replay.webgl.BlendShaderFragment.OPTIMIZED_SOURCE;
/**
 * @constructor
 * @extends {ol.webgl.shader.Vertex}
 * @param {WebGLRenderingContext} gl GL.
 */
ol.renderer.replay.webgl.BlendShaderVertex = function(gl) {
  goog.base(this,
    ol.renderer.replay.webgl.BlendShader.sourcePreamble_(gl) + ol.renderer.replay.webgl.BlendShaderVertex.SOURCE);
};
goog.inherits(ol.renderer.replay.webgl.BlendShaderVertex, ol.webgl.shader.Vertex);
/**
 * @const
 * @type {string}
 */
ol.renderer.replay.webgl.BlendShaderVertex.DEBUG_SOURCE =
    '//! NAMESPACE=ol.renderer.replay.webgl.BlendShader\n//! CLASS=ol.renderer.replay.webgl.BlendShader\n\n//! COMMON\n\nvarying vec2 TexCoord;\n\n\n//! VERTEX\n\nattribute vec4 Position;\n\nvoid main(void) {\n\n    gl_Position = Position;\n    TexCoord = (abs(Position.xy) + Position.xy) * 0.5;\n}\n\n\n';
/**
 * @const
 * @type {string}
 */
ol.renderer.replay.webgl.BlendShaderVertex.OPTIMIZED_SOURCE =
    'varying vec2 a;attribute vec4 b;void main(){gl_Position=b;a=(abs(b.xy)+b.xy)*.5;}';
/**
 * @const
 * @type {string}
 */
ol.renderer.replay.webgl.BlendShaderVertex.SOURCE = goog.DEBUG ?
    ol.renderer.replay.webgl.BlendShaderVertex.DEBUG_SOURCE :
    ol.renderer.replay.webgl.BlendShaderVertex.OPTIMIZED_SOURCE;
/**
 * @constructor
 * @param {WebGLRenderingContext} gl GL.
 * @param {WebGLProgram} program Program.
 */
ol.renderer.replay.webgl.BlendShader.Locations = function(gl, program) {
  /**
   * @type {WebGLUniformLocation}
   */
  this.Opacity = gl.getUniformLocation(
      program, goog.DEBUG ? 'Opacity' : 'b');
  /**
   * @type {WebGLUniformLocation}
   */
  this.Sampler0 = gl.getUniformLocation(
      program, goog.DEBUG ? 'Sampler0' : 'c');
  /**
   * @type {number}
   */
  this.Position = gl.getAttribLocation(
      program, goog.DEBUG ? 'Position' : 'b');
};
/**
 * Generates a source preamble from the expressions in JSCONST
 * directives.
 * We have the rendering context passed in to allow querying
 * extensions and context attributes.
 *
 * @private
 * @param {WebGLRenderingContext} gl GL.
 * @return {string} Shader source preamble.
 */
ol.renderer.replay.webgl.BlendShader.sourcePreamble_ = function(gl) {
  return ('' +
'\n');
};
