// This file is automatically generated, do not edit
goog.provide('ol.renderer.replay.webgl.geom.LineRenderShader');
goog.require('ol.webgl.shader');
/**
 * @constructor
 * @extends {ol.webgl.shader.Fragment}
 * @param {WebGLRenderingContext} gl GL.
 */
ol.renderer.replay.webgl.geom.LineRenderShaderFragment = function(gl) {
  goog.base(this,
    ol.renderer.replay.webgl.geom.LineRenderShader.sourcePreamble_(gl) + ol.renderer.replay.webgl.geom.LineRenderShaderFragment.SOURCE);
};
goog.inherits(ol.renderer.replay.webgl.geom.LineRenderShaderFragment, ol.webgl.shader.Fragment);
/**
 * @const
 * @type {string}
 */
ol.renderer.replay.webgl.geom.LineRenderShaderFragment.DEBUG_SOURCE = '//! NAMESPACE=ol.renderer.replay.webgl.geom.LineRenderShader\n//! CLASS=ol.renderer.replay.webgl.geom.LineRenderShader\n\n//! COMMON\n\n\n//! FRAGMENT\n//! JSCONST PREMULTIPLY_BY_ALPHA Number(gl.getContextAttributes().premultipliedAlpha)\n\nprecision mediump float;\n\n// ---- Interface\n\nuniform vec3 RenderParams;\nfloat antiAliasing = RenderParams.x;\nfloat rcpGammaOut = RenderParams.z;\n\nvarying vec3 Surface_Opacity;\nvarying vec4 Color_NegHorizSurfScale;\n\n// ---- Implementation\n\nfloat blendCoeff(vec2 edge0, vec2 edge1, vec2 x) {\n  vec2 weight = smoothstep(edge0, edge1, x);\n  return max(weight.x, weight.y);\n}\n\nvec3 gammaCorrect(vec3 color) {\n  return pow(clamp(color, 0.0, 1.0), vec3(rcpGammaOut));\n}\n\nvoid main(void) {\n\n    // Distance from center of surface coordinate (keep it this way;\n    // strangely the \'abs\' function does not work correctly on all\n    // platforms here)\n    vec2 dist = min(Surface_Opacity.xy * sign(Surface_Opacity.xy), 1.0);\n\n    vec2 negScale = vec2(Color_NegHorizSurfScale.w, -1.0 / antiAliasing);\n    vec2 outerEdgeMin = vec2(1.0) + negScale * antiAliasing;\n\n    float alpha = Surface_Opacity.z  * \n        (1.0 - blendCoeff(outerEdgeMin, vec2(1.0), dist));\n\n    vec3 color = gammaCorrect(Color_NegHorizSurfScale.rgb);\n\n#if PREMULTIPLY_BY_ALPHA\n    color.rgb *= alpha;\n#endif\n    gl_FragColor = vec4(color, alpha);\n}\n\n';
/**
 * @const
 * @type {string}
 */
ol.renderer.replay.webgl.geom.LineRenderShaderFragment.OPTIMIZED_SOURCE = 'precision mediump float;uniform vec3 d;float g=d.x;float h=d.z;varying vec3 e;varying vec4 f;float n(vec2 i,vec2 j,vec2 k){vec2 l=smoothstep(i,j,k);return max(l.x,l.y);}vec3 o(vec3 i){return pow(clamp(i,0.,1.),vec3(h));}void main(){vec2 i,j,k;i=min(e.xy*sign(e.xy),1.);j=vec2(f.w,-1./g);k=vec2(1)+j*g;float l=e.z*(1.-n(k,vec2(1),i));vec3 m=o(f.rgb);\n#if PREMULTIPLY_BY_ALPHA\nm.rgb*=l;\n#endif\ngl_FragColor=vec4(m,l);}';
/**
 * @const
 * @type {string}
 */
ol.renderer.replay.webgl.geom.LineRenderShaderFragment.SOURCE = goog.DEBUG ?
    ol.renderer.replay.webgl.geom.LineRenderShaderFragment.DEBUG_SOURCE :
    ol.renderer.replay.webgl.geom.LineRenderShaderFragment.OPTIMIZED_SOURCE;
/**
 * @constructor
 * @extends {ol.webgl.shader.Vertex}
 * @param {WebGLRenderingContext} gl GL.
 */
ol.renderer.replay.webgl.geom.LineRenderShaderVertex = function(gl) {
  goog.base(this,
    ol.renderer.replay.webgl.geom.LineRenderShader.sourcePreamble_(gl) + ol.renderer.replay.webgl.geom.LineRenderShaderVertex.SOURCE);
};
goog.inherits(ol.renderer.replay.webgl.geom.LineRenderShaderVertex, ol.webgl.shader.Vertex);
/**
 * @const
 * @type {string}
 */
ol.renderer.replay.webgl.geom.LineRenderShaderVertex.DEBUG_SOURCE = '//! NAMESPACE=ol.renderer.replay.webgl.geom.LineRenderShader\n//! CLASS=ol.renderer.replay.webgl.geom.LineRenderShader\n\n//! COMMON\n\n\n//! VERTEX\n\nprecision highp float;\n\n// ---- Interface\n\nattribute vec4 PositionP;\nattribute vec4 Position0;\nattribute vec4 PositionN;\nattribute float Control;\n\nattribute vec4 Style;\n// extent\n// color (rgb)\n// opacity (floor 0..255), outline width (fract)\n// stroke color (rgb)\n\nuniform vec4 Pretranslation;\nuniform mat4 Transform;\nuniform vec2 PixelScale;\n\nuniform mediump vec3 RenderParams;\nfloat antiAliasing = RenderParams.x;\nfloat rcpGammaIn = RenderParams.y;\n//-float rcpGammaOut = RenderParams.z; - used in fragment shader\n\nvarying vec3 Surface_Opacity;\nvarying vec4 Color_NegHorizSurfScale;\n\n\n// ---- Implementation\n\nvec4 pretranslate(vec4 highPrecEncodedCoord) {\n    vec4 v = highPrecEncodedCoord + Pretranslation;\n    v.xy += v.zw;\n    v.zw = vec2(0.0, 1.0);\n    return v;\n}\n\nvec3 decodeRGB(float v) {\n\n    const float downshift16 = 1. / 65536.;\n    const float downshift8  = 1. /   256.;\n\n    return vec3(fract(v * downshift16), \n                fract(v * downshift8),\n                fract(v));\n}\n\nvec3 gammaApply(vec3 color) {\n    return pow(clamp(color, 0.0, 1.0), vec3(rcpGammaIn));\n}\n\nvec2 rotateCw(vec2 p) {\n    return vec2(p.y, -p.x);\n}\n\nvec2 rotateCcw(vec2 p) {\n    return vec2(-p.y, p.x);\n}\n\nvec3 perspDiv(vec4 p) {\n    return p.xyz / p.w;\n}\n\nvec2 safeNormalize(vec2 v) {\n    float frob = dot(v, v);\n    return v * (frob > 0.0 ? inversesqrt(frob) : 0.0);\n}\n\nconst float CTRL_LINE_CENTER = 16.0;\nconst float CTRL_TERMINAL = 8.0;\nconst float CTRL_RIGHT_EDGE = 4.0;\nconst float CTRL_OUTGOING_EDGE = 2.0;\n\nvec2 lineExtrusion(out vec2 texCoord,\n                   vec2 coordPrev, vec2 coordHere, vec2 coordNext,\n                   float ctrl, float extent, float lengthOfEnds,\n                   vec2 scale, float reciprocalRelativeMiterLimit) {\n\n    vec2 result = vec2(0.);\n    texCoord = vec2(-1., 0.);\n\n    vec2 dirIncoming = safeNormalize(coordHere - coordPrev);\n    vec2 dirOutgoing = safeNormalize(coordNext - coordHere);\n    vec2 outward = safeNormalize(dirIncoming - dirOutgoing);\n\n    float sinWinding = dot(\n        rotateCcw(dirIncoming),   // normal to the left of incoming leg\n        outward);                 // vertex normal on the convex side\n    float sgnWinding = sign(sinWinding);\n\n    float absSinWinding = sinWinding * sgnWinding;\n    float cosWinding = sqrt(1. - sinWinding * sinWinding);\n    float relativeMiterLimit = 1.0 / reciprocalRelativeMiterLimit;\n    float normBevelWidth = absSinWinding + relativeMiterLimit;\n    float cutWidth = length(vec2(normBevelWidth, cosWinding));\n\n    if (ctrl == CTRL_LINE_CENTER) {\n        // Move the vertex inward and calculate texture coordinate\n        result = outward * -extent * relativeMiterLimit * scale;\n        texCoord.x = -sgnWinding + sgnWinding * 2. * normBevelWidth / cutWidth;\n        return result;\n    }\n\n    if (ctrl >= CTRL_TERMINAL) {\n        ctrl -= CTRL_TERMINAL;\n        // Extrude in outward direction (the \'outward\' vector degenerates\n        // to point outward in vertical direction in this case)\n        result = outward * lengthOfEnds;\n        // Let surface coordinate indicate the edge - we can use the same\n        // value for both ends as interpolating towards zero in all cases\n        texCoord.y = 1.0;\n        // The nonzero edge we see in this case is in opposite direction\n        extent = -extent;\n        // We\'re on a straight segment, force beveling logic (there is no\n        // bevel but \n        absSinWinding = 0.0; \n    }\n\n    if (ctrl >= CTRL_RIGHT_EDGE) {\n        ctrl -= CTRL_RIGHT_EDGE;\n        // Set surface coordinate, negate horizontal amount\n        texCoord.x = 1.0;\n        extent = -extent;\n    }\n\n    vec2 legDir;\n    float extraMove = 0.0;\n    const float epsRadians = 0.000244140625;\n    if (absSinWinding < reciprocalRelativeMiterLimit) {\n        // Bevel (miter too long)?\n        legDir = ctrl == CTRL_OUTGOING_EDGE ? dirOutgoing : dirIncoming;\n        result += extent * rotateCcw(legDir);\n\n        if (texCoord.x == sgnWinding && absSinWinding > epsRadians) {\n            // Unless at a line ending (this includes the vertices next\n            // to the ones flagged as terminal), pull back the inner two\n            // edges in order to expose the bevel triangle\n            extraMove = (1.0 - cutWidth) * abs(extent); \n        }\n    } else \n    // ATTENTION: Don\'t remove the redunant "if", here! It\'s a workaround\n    // for a vicious bug in ANGLE m)\n    if (absSinWinding >= reciprocalRelativeMiterLimit) {\n        // Miter\n        legDir = rotateCw(outward);\n        result += (extent / sinWinding) * outward;\n\n        if (absSinWinding > epsRadians) {\n            // Cull triangles for bevel unless at line endings (there are\n            // none in this case) to prevent flickering while avoiding to \n            // globally enforce invariance\n            const float epsPixels = 0.000244140625;\n            extraMove = sgnWinding * epsPixels;\n        }\n    }\n    result += extraMove * (ctrl == CTRL_OUTGOING_EDGE ? -1. : 1.) * legDir;\n\n    return result * scale;\n}\n\nvoid main(void) {\n\n    // Basic vertex shader operation\n    gl_Position = Transform * pretranslate(Position0);\n\n    // Decode colors and opacity from style\n    Color_NegHorizSurfScale.rgb = gammaApply(decodeRGB(Style.y));\n    float lineMode = max(sign(Style.z), 0.0);\n    float alphaAndWidth = Style.z * sign(Style.z);\n    Surface_Opacity = vec3(-lineMode, 0.0, floor(alphaAndWidth) / 255.0);\n\n    // Decode line widths from style and prepare for rendering\n    float extent = Style.x * (0.5 + lineMode * 0.5);\n    float actExtent = extent + antiAliasing * 0.5;\n    Color_NegHorizSurfScale.w = -1.0 / actExtent;\n\n    // Apply to 2D position in NDC\n    gl_Position.xy += lineExtrusion(Surface_Opacity.xy,\n            perspDiv(Transform * pretranslate(PositionP)).xy,\n            perspDiv(gl_Position).xy,\n            perspDiv(Transform * pretranslate(PositionN)).xy,\n            Control, actExtent, antiAliasing,\n            PixelScale, 0.5);\n}\n\n';
/**
 * @const
 * @type {string}
 */
ol.renderer.replay.webgl.geom.LineRenderShaderVertex.OPTIMIZED_SOURCE = 'precision highp float;attribute vec4 g,h,i,k;attribute float j;uniform vec4 a;uniform mat4 b;uniform vec2 c;uniform mediump vec3 d;float l=d.x;float m=d.y;varying vec3 e;varying vec4 f;vec4 P(vec4 r){vec4 s=r+a;s.xy+=s.zw;s.zw=vec2(0,1);return s;}vec3 Q(float r){const float s=1./65536.;const float t=1./256.;return vec3(fract(r*s),fract(r*t),fract(r));}vec3 R(vec3 r){return pow(clamp(r,0.,1.),vec3(m));}vec2 S(vec2 r){return vec2(r.y,-r.x);}vec2 T(vec2 r){return vec2(-r.y,r.x);}vec3 U(vec4 r){return r.xyz/r.w;}vec2 V(vec2 r){float s=dot(r,r);return r*(s>0.?inversesqrt(s):0.);}const float n=16.;const float o=8.;const float p=4.;const float q=2.;vec2 W(out vec2 r,vec2 s,vec2 t,vec2 u,float v,float w,float x,vec2 y,float z){vec2 A,B,C,D,L;A=vec2(0);r=vec2(-1.,0);B=V(t-s);C=V(u-t);D=V(B-C);float E,F,G,H,I,J,K,M;E=dot(T(B),D);F=sign(E);G=E*F;H=sqrt(1.-E*E);I=1./z;J=G+I;K=length(vec2(J,H));if(v==n){A=D*-w*I*y;r.x=-F+F*2.*J/K;return A;}if(v>=o){v-=o;A=D*x;r.y=1.;w=-w;G=0.;}if(v>=p){v-=p;r.x=1.;w=-w;}M=0.;const float N=.000244140625;if(G<z){L=v==q?C:B;A+=w*T(L);if(r.x==F&&G>N)M=(1.-K)*abs(w);}else if(G>=z){L=S(D);A+=w/E*D;if(G>N){const float O=.000244140625;M=F*O;}}A+=M*(v==q?-1.:1.)*L;return A*y;}void main(){gl_Position=b*P(h);f.rgb=R(Q(k.y));float r,s,t,u;r=max(sign(k.z),0.);s=k.z*sign(k.z);e=vec3(-r,0,floor(s)/255.);t=k.x*(.5+r*.5);u=t+l*.5;f.w=-1./u;gl_Position.xy+=W(e.xy,U(b*P(g)).xy,U(gl_Position).xy,U(b*P(i)).xy,j,u,l,c,.5);}';
/**
 * @const
 * @type {string}
 */
ol.renderer.replay.webgl.geom.LineRenderShaderVertex.SOURCE = goog.DEBUG ?
    ol.renderer.replay.webgl.geom.LineRenderShaderVertex.DEBUG_SOURCE :
    ol.renderer.replay.webgl.geom.LineRenderShaderVertex.OPTIMIZED_SOURCE;
/**
 * @constructor
 * @param {WebGLRenderingContext} gl GL.
 * @param {WebGLProgram} program Program.
 */
ol.renderer.replay.webgl.geom.LineRenderShader.Locations = function(gl, program) {
  /**
   * @type {WebGLUniformLocation}
   */
  this.Pretranslation = gl.getUniformLocation(
      program, goog.DEBUG ? 'Pretranslation' : 'a');
  /**
   * @type {WebGLUniformLocation}
   */
  this.Transform = gl.getUniformLocation(
      program, goog.DEBUG ? 'Transform' : 'b');
  /**
   * @type {WebGLUniformLocation}
   */
  this.PixelScale = gl.getUniformLocation(
      program, goog.DEBUG ? 'PixelScale' : 'c');
  /**
   * @type {WebGLUniformLocation}
   */
  this.RenderParams = gl.getUniformLocation(
      program, goog.DEBUG ? 'RenderParams' : 'd');
  /**
   * @type {number}
   */
  this.PositionP = gl.getAttribLocation(
      program, goog.DEBUG ? 'PositionP' : 'g');
  /**
   * @type {number}
   */
  this.Position0 = gl.getAttribLocation(
      program, goog.DEBUG ? 'Position0' : 'h');
  /**
   * @type {number}
   */
  this.PositionN = gl.getAttribLocation(
      program, goog.DEBUG ? 'PositionN' : 'i');
  /**
   * @type {number}
   */
  this.Control = gl.getAttribLocation(
      program, goog.DEBUG ? 'Control' : 'j');
  /**
   * @type {number}
   */
  this.Style = gl.getAttribLocation(
      program, goog.DEBUG ? 'Style' : 'k');
};
/**
 * Generates a source preamble from the expressions in JSCONST
 * directives.
 * We have the rendering context passed in to allow querying
 * extensions and context attributes.
 *
 * @private
 * @param {WebGLRenderingContext} gl GL.
 * @return {string} Shader source preamble.
 */
ol.renderer.replay.webgl.geom.LineRenderShader.sourcePreamble_ = function(gl) {
  return (
      '\n#define ' +
        (goog.DEBUG ? 'PREMULTIPLY_BY_ALPHA' : 'PREMULTIPLY_BY_ALPHA') +
        ' ' + (Number(gl.getContextAttributes().premultipliedAlpha)) +
'\n');
};
