// This file is automatically generated, do not edit
goog.provide('ol.renderer.replay.webgl.geom.LineStringsRenderShader');
goog.require('ol.webgl.shader');
goog.require('ol.renderer.replay.webgl.geom.LineStringsBatcher');
/**
 * @constructor
 * @extends {ol.webgl.shader.Fragment}
 * @param {WebGLRenderingContext} gl GL.
 */
ol.renderer.replay.webgl.geom.LineStringsRenderShaderFragment = function(gl) {
  goog.base(this,
    ol.renderer.replay.webgl.geom.LineStringsRenderShader.sourcePreamble_(gl) + ol.renderer.replay.webgl.geom.LineStringsRenderShaderFragment.SOURCE);
};
goog.inherits(ol.renderer.replay.webgl.geom.LineStringsRenderShaderFragment, ol.webgl.shader.Fragment);
/**
 * @const
 * @type {string}
 */
ol.renderer.replay.webgl.geom.LineStringsRenderShaderFragment.DEBUG_SOURCE =
    '//! NAMESPACE=ol.renderer.replay.webgl.geom.LineStringsRenderShader\n//! CLASS=ol.renderer.replay.webgl.geom.LineStringsRenderShader\n\n//! COMMON\n\nvarying vec4 Color;\nvarying vec3 Surface;\n\nuniform mediump vec2 PixelScale;\nuniform mediump vec2 RenderParams;\nmediump float antiAliasing  = RenderParams.x;\nmediump float rcpGammaIn    = RenderParams.y;\n\n\n\nvec3 applyGamma(vec3 color, float reciprocalGamma) {\n    return pow(color, vec3(reciprocalGamma));\n}\n\nvec2 rotatedCw(vec2 p) {\n    return vec2(p.y, -p.x);\n}\n\nvec2 rotatedCcw(vec2 p) {\n    return vec2(-p.y, p.x);\n}\n\n// Machine epsilon is at ~0.6*10^-8 for a typical 32 bit ALU.\n// Usually we don\'t need the precision of the entire mantissa \n// but at some point the vector becomes rather useless.\n// Also, sometimes just error dirt creep up the low bits for\n// values that should yield zero.\nconst float NORM_EPS = 0.000000001;\n\nvec2 safeNormalized(vec2 v) {\n\n    float frob = dot(v, v);\n    return v * (frob > NORM_EPS ? inversesqrt(frob) : 0.0);\n}\n\nvec2 safeNormalized(vec2 v, vec2 fallback) {\n\n    float frob = dot(v, v);\n    return frob > NORM_EPS ? v * inversesqrt(frob) : fallback;\n}\n\nvec3 projected(vec4 p) {\n    return p.xyz / p.w;\n}\n\nvec3 decodeRGB(float v) {\n\n    const float downshift16 = 1. / 65536.;\n    const float downshift8  = 1. /   256.;\n\n    return vec3(v * downshift16, fract(v * downshift8), fract(v));\n}\n\nvec2 decodeUV(float v) {\n    const float downshift12 = 1. / 4096.;\n\n    return vec2(floor(v) * downshift12, fract(v));\n}\n\nvec2 decodeVec2I12(float v) {\n    const float upshift12 = 4096.;\n    const float offset = -2048.;\n\n    return vec2(floor(v) + offset, fract(v) * upshift12 + offset);\n}\n\nvec2 decodeVec2U12(float v) {\n    const float upshift12 = 4096.;\n\n    return vec2(floor(v), fract(v) * upshift12);\n}\n\nvec4 rteDecode(vec4 highPrecCoord, vec4 highPrecOffset) {\n\n    vec4 v = highPrecCoord + highPrecOffset;\n    v.xy += v.zw;\n    v.zw = vec2(0.0, 1.0);\n    return v;\n}\n\n\n//! FRAGMENT\n\nuniform sampler2D Background;\n\nfloat blendCoeff(vec2 edge0, vec2 edge1, vec2 x) {\n\n    vec2 weight = smoothstep(edge0, edge1, x);\n    return max(weight.x, weight.y);\n}\n\nvoid main(void) {\n\n    // Distance from center of surface coordinate\n    // ATTENTION: Do not change strange absolute computation - it is a\n    // workaround for \'abs\' being effectless on a varying with ANGLE.\n    vec2 dist = min(Surface.xy * sign(Surface.xy), 1.0);\n\n    vec2 negScale = vec2(Surface.z, -1.0 / antiAliasing);\n    vec2 outerEdgeMin = vec2(1.0) + negScale * antiAliasing;\n\n    gl_FragColor.rgb = Color.a < 1.0\n        ? mix(texture2D(Background, gl_FragCoord.xy * PixelScale * 0.5).rgb,\n              Color.rgb, Color.a)\n        : Color.rgb;\n\n    gl_FragColor.a = sqrt(1.0 - blendCoeff(outerEdgeMin, vec2(1.0), dist));\n}\n\n';
/**
 * @const
 * @type {string}
 */
ol.renderer.replay.webgl.geom.LineStringsRenderShaderFragment.OPTIMIZED_SOURCE =
    'varying vec4 a;varying vec3 b;uniform mediump vec2 c,d;mediump float h=d.x;mediump float i=d.y;const float j=1e-9;uniform sampler2D g;float o(vec2 k,vec2 l,vec2 m){vec2 n=smoothstep(k,l,m);return max(n.x,n.y);}void main(){vec2 k,l,m;k=min(b.xy*sign(b.xy),1.);l=vec2(b.z,-1./h);m=vec2(1)+l*h;gl_FragColor.rgb=a.a<1.?mix(texture2D(g,gl_FragCoord.xy*c*.5).rgb,a.rgb,a.a):a.rgb;gl_FragColor.a=sqrt(1.-o(m,vec2(1),k));}';
/**
 * @const
 * @type {string}
 */
ol.renderer.replay.webgl.geom.LineStringsRenderShaderFragment.SOURCE = goog.DEBUG ?
    ol.renderer.replay.webgl.geom.LineStringsRenderShaderFragment.DEBUG_SOURCE :
    ol.renderer.replay.webgl.geom.LineStringsRenderShaderFragment.OPTIMIZED_SOURCE;
/**
 * @constructor
 * @extends {ol.webgl.shader.Vertex}
 * @param {WebGLRenderingContext} gl GL.
 */
ol.renderer.replay.webgl.geom.LineStringsRenderShaderVertex = function(gl) {
  goog.base(this,
    ol.renderer.replay.webgl.geom.LineStringsRenderShader.sourcePreamble_(gl) + ol.renderer.replay.webgl.geom.LineStringsRenderShaderVertex.SOURCE);
};
goog.inherits(ol.renderer.replay.webgl.geom.LineStringsRenderShaderVertex, ol.webgl.shader.Vertex);
/**
 * @const
 * @type {string}
 */
ol.renderer.replay.webgl.geom.LineStringsRenderShaderVertex.DEBUG_SOURCE =
    '//! NAMESPACE=ol.renderer.replay.webgl.geom.LineStringsRenderShader\n//! CLASS=ol.renderer.replay.webgl.geom.LineStringsRenderShader\n\n//! COMMON\n\nvarying vec4 Color;\nvarying vec3 Surface;\n\nuniform mediump vec2 PixelScale;\nuniform mediump vec2 RenderParams;\nmediump float antiAliasing  = RenderParams.x;\nmediump float rcpGammaIn    = RenderParams.y;\n\n//! VERTEX\n\n//! INCLUDE common_lib.glsl\n\n\nvec3 applyGamma(vec3 color, float reciprocalGamma) {\n    return pow(color, vec3(reciprocalGamma));\n}\n\nvec2 rotatedCw(vec2 p) {\n    return vec2(p.y, -p.x);\n}\n\nvec2 rotatedCcw(vec2 p) {\n    return vec2(-p.y, p.x);\n}\n\n// Machine epsilon is at ~0.6*10^-8 for a typical 32 bit ALU.\n// Usually we don\'t need the precision of the entire mantissa \n// but at some point the vector becomes rather useless.\n// Also, sometimes just error dirt creep up the low bits for\n// values that should yield zero.\nconst float NORM_EPS = 0.000000001;\n\nvec2 safeNormalized(vec2 v) {\n\n    float frob = dot(v, v);\n    return v * (frob > NORM_EPS ? inversesqrt(frob) : 0.0);\n}\n\nvec2 safeNormalized(vec2 v, vec2 fallback) {\n\n    float frob = dot(v, v);\n    return frob > NORM_EPS ? v * inversesqrt(frob) : fallback;\n}\n\nvec3 projected(vec4 p) {\n    return p.xyz / p.w;\n}\n\n//! INCLUDE gpudata_lib.glsl\nvec3 decodeRGB(float v) {\n\n    const float downshift16 = 1. / 65536.;\n    const float downshift8  = 1. /   256.;\n\n    return vec3(v * downshift16, fract(v * downshift8), fract(v));\n}\n\nvec2 decodeUV(float v) {\n    const float downshift12 = 1. / 4096.;\n\n    return vec2(floor(v) * downshift12, fract(v));\n}\n\nvec2 decodeVec2I12(float v) {\n    const float upshift12 = 4096.;\n    const float offset = -2048.;\n\n    return vec2(floor(v) + offset, fract(v) * upshift12 + offset);\n}\n\nvec2 decodeVec2U12(float v) {\n    const float upshift12 = 4096.;\n\n    return vec2(floor(v), fract(v) * upshift12);\n}\n\nvec4 rteDecode(vec4 highPrecCoord, vec4 highPrecOffset) {\n\n    vec4 v = highPrecCoord + highPrecOffset;\n    v.xy += v.zw;\n    v.zw = vec2(0.0, 1.0);\n    return v;\n}\n\n\n\nattribute vec4 PositionP;\nattribute vec4 Position0;\nattribute vec4 PositionN;\nattribute float Control;\n\nattribute vec4 Style;\n// extent\n// color (rgb)\n// opacity (0..1)\n// reciprocal miter limit\n\nuniform vec4 Pretranslation;\nuniform mat4 Transform;\n\n//! JSREQUIRE ol.renderer.replay.webgl.geom.LineStringsBatcher\n//! JSCONST CTRL_LINE_CENTER   ol.renderer.replay.webgl.geom.LineStringsBatcher.SurfaceFlags.CENTER.toFixed(1)\n//! JSCONST CTRL_TERMINAL      ol.renderer.replay.webgl.geom.LineStringsBatcher.SurfaceFlags.TERMINAL.toFixed(1)\n//! JSCONST CTRL_RIGHT_EDGE    ol.renderer.replay.webgl.geom.LineStringsBatcher.SurfaceFlags.RIGHT.toFixed(1)\n//! JSCONST CTRL_OUTGOING_EDGE ol.renderer.replay.webgl.geom.LineStringsBatcher.SurfaceFlags.OUTGOING.toFixed(1)\n\nvec2 lineExtrusion(out vec2 texCoord,\n                   vec2 coordPrev, vec2 coordHere, vec2 coordNext,\n                   float ctrl, float extent, float lengthOfEnds,\n                   float reciprocalRelativeMiterLimit) {\n\n    vec2 result = vec2(0.);\n    texCoord = vec2(-1., 0.);\n\n    vec2 dirIncoming = safeNormalized(coordHere - coordPrev);\n    vec2 dirOutgoing = safeNormalized(coordNext - coordHere);\n    vec2 outward = safeNormalized(dirIncoming - dirOutgoing, rotatedCcw(dirIncoming));\n\n    float sgnCosWinding = dot(\n        rotatedCcw(dirIncoming),  // normal to the left of incoming leg\n        outward);                 // vertex normal on the convex side\n    float sgnWinding = sign(sgnCosWinding);\n\n    float cosWinding = sgnCosWinding * sgnWinding;\n    float absSinWinding = sqrt(1. - sgnCosWinding * sgnCosWinding);\n    float relativeMiterLimit = 1.0 / reciprocalRelativeMiterLimit;\n    float normBevelWidth = cosWinding + relativeMiterLimit;\n    float cutWidth = length(vec2(normBevelWidth, absSinWinding));\n\n    if (ctrl == CTRL_LINE_CENTER) {\n        // Move the vertex inward and calculate texture coordinate\n        result = outward * -extent * relativeMiterLimit;\n        texCoord.x = -sgnWinding + sgnWinding * 2. * normBevelWidth / cutWidth;\n        return result;\n    }\n\n    if (ctrl >= CTRL_TERMINAL) {\n        ctrl -= CTRL_TERMINAL;\n        // Extrude in outward direction (the \'outward\' vector degenerates\n        // to point outward in vertical direction in this case)\n        result = outward * lengthOfEnds;\n        // Let surface coordinate indicate the edge - we can use the same\n        // value for both ends as interpolating towards zero in all cases\n        texCoord.y = 1.0;\n        // The nonzero edge we see in this case is in opposite direction\n        extent = -extent;\n        // We\'re on a straight segment, force beveling logic (there is no\n        // bevel but it will do the right thing) \n        cosWinding = 0.0; \n    }\n\n    if (ctrl >= CTRL_RIGHT_EDGE) {\n        ctrl -= CTRL_RIGHT_EDGE;\n        // Set surface coordinate, negate horizontal amount\n        texCoord.x = 1.0;\n        extent = -extent;\n    }\n\n    vec2 legDir;\n    float extraMove = 0.0;\n    const float epsRadians = 0.000244140625;\n    if (cosWinding < reciprocalRelativeMiterLimit) {\n        // Bevel (miter too long)?\n        legDir = ctrl == CTRL_OUTGOING_EDGE ? dirOutgoing : dirIncoming;\n        result += extent * rotatedCcw(legDir);\n\n        if (texCoord.x == sgnWinding && cosWinding > epsRadians) {\n            // Unless at a line ending (this includes the vertices next\n            // to the ones flagged as terminal), pull back the inner two\n            // edges in order to expose the bevel triangle\n            extraMove = (1.0 - cutWidth) * abs(extent); \n        }\n    } else \n    // ATTENTION: Don\'t remove the redunant "if", here! It\'s a workaround\n    // for a vicious bug in ANGLE m)\n    if (cosWinding >= reciprocalRelativeMiterLimit) {\n        // Miter\n        legDir = rotatedCw(outward);\n        result += (extent / sgnCosWinding) * outward;\n\n        if (cosWinding > epsRadians) {\n            // Cull triangles for bevel unless at line endings (there are\n            // none in this case) to prevent flickering while avoiding to \n            // globally enforce invariance\n            const float epsPixels = 0.000244140625;\n            extraMove = sgnWinding * epsPixels;\n        }\n    }\n    result += extraMove * (ctrl == CTRL_OUTGOING_EDGE ? -1. : 1.) * legDir;\n\n    return result;\n}\n\nvoid main(void) {\n\n    // Basic vertex shader operation\n    gl_Position = Transform * rteDecode(Position0, Pretranslation);\n\n    // Decode style\n    Color = vec4(applyGamma(decodeRGB(Style.y), rcpGammaIn), Style.z);\n    float extent = Style.x + antiAliasing * 0.5; // half the smoothing counts\n    Surface.z = -1.0 / extent; // negative scale for Surface.x\n    float rcpMiterLimit = Style.w;\n\n    // Apply to 2D position in NDC\n    gl_Position.xy += lineExtrusion(Surface.xy,\n            projected(Transform * rteDecode(PositionP, Pretranslation)).xy,\n            projected(gl_Position).xy,\n            projected(Transform * rteDecode(PositionN, Pretranslation)).xy,\n            Control, extent, antiAliasing, rcpMiterLimit) * \n            gl_Position.w * PixelScale;\n}\n\n\n';
/**
 * @const
 * @type {string}
 */
ol.renderer.replay.webgl.geom.LineStringsRenderShaderVertex.OPTIMIZED_SOURCE =
    'varying vec4 a;varying vec3 b;uniform mediump vec2 c,d;mediump float g=d.x;mediump float h=d.y;vec3 L(vec3 o,float p){return pow(o,vec3(p));}vec2 M(vec2 o){return vec2(o.y,-o.x);}vec2 N(vec2 o){return vec2(-o.y,o.x);}const float i=1e-9;vec2 O(vec2 o){float p=dot(o,o);return o*(p>i?inversesqrt(p):0.);}vec2 O(vec2 o,vec2 p){float q=dot(o,o);return q>i?o*inversesqrt(q):p;}vec3 P(vec4 o){return o.xyz/o.w;}vec3 Q(float o){const float p=1./65536.;const float q=1./256.;return vec3(o*p,fract(o*q),fract(o));}vec4 R(vec4 o,vec4 p){vec4 q=o+p;q.xy+=q.zw;q.zw=vec2(0,1);return q;}attribute vec4 j,k,l,n;attribute float m;uniform vec4 e;uniform mat4 f;vec2 S(out vec2 o,vec2 p,vec2 q,vec2 r,float s,float t,float u,float v){vec2 w,x,y,z,H;w=vec2(0);o=vec2(-1.,0);x=O(q-p);y=O(r-q);z=O(x-y,N(x));float A,B,C,D,E,F,G,I;A=dot(N(x),z);B=sign(A);C=A*B;D=sqrt(1.-A*A);E=1./v;F=C+E;G=length(vec2(F,D));if(s==CTRL_LINE_CENTER){w=z*-t*E;o.x=-B+B*2.*F/G;return w;}if(s>=CTRL_TERMINAL){s-=CTRL_TERMINAL;w=z*u;o.y=1.;t=-t;C=0.;}if(s>=CTRL_RIGHT_EDGE){s-=CTRL_RIGHT_EDGE;o.x=1.;t=-t;}I=0.;const float J=.000244140625;if(C<v){H=s==CTRL_OUTGOING_EDGE?y:x;w+=t*N(H);if(o.x==B&&C>J)I=(1.-G)*abs(t);}else if(C>=v){H=M(z);w+=t/A*z;if(C>J){const float K=.000244140625;I=B*K;}}w+=I*(s==CTRL_OUTGOING_EDGE?-1.:1.)*H;return w;}void main(){gl_Position=f*R(k,e);a=vec4(L(Q(n.y),h),n.z);float o,p;o=n.x+g*.5;b.z=-1./o;p=n.w;gl_Position.xy+=S(b.xy,P(f*R(j,e)).xy,P(gl_Position).xy,P(f*R(l,e)).xy,m,o,g,p)*gl_Position.w*c;}';
/**
 * @const
 * @type {string}
 */
ol.renderer.replay.webgl.geom.LineStringsRenderShaderVertex.SOURCE = goog.DEBUG ?
    ol.renderer.replay.webgl.geom.LineStringsRenderShaderVertex.DEBUG_SOURCE :
    ol.renderer.replay.webgl.geom.LineStringsRenderShaderVertex.OPTIMIZED_SOURCE;
/**
 * @constructor
 * @param {WebGLRenderingContext} gl GL.
 * @param {WebGLProgram} program Program.
 */
ol.renderer.replay.webgl.geom.LineStringsRenderShader.Locations = function(gl, program) {
  /**
   * @type {WebGLUniformLocation}
   */
  this.PixelScale = gl.getUniformLocation(
      program, goog.DEBUG ? 'PixelScale' : 'c');
  /**
   * @type {WebGLUniformLocation}
   */
  this.RenderParams = gl.getUniformLocation(
      program, goog.DEBUG ? 'RenderParams' : 'd');
  /**
   * @type {WebGLUniformLocation}
   */
  this.Pretranslation = gl.getUniformLocation(
      program, goog.DEBUG ? 'Pretranslation' : 'e');
  /**
   * @type {WebGLUniformLocation}
   */
  this.Transform = gl.getUniformLocation(
      program, goog.DEBUG ? 'Transform' : 'f');
  /**
   * @type {WebGLUniformLocation}
   */
  this.Background = gl.getUniformLocation(
      program, goog.DEBUG ? 'Background' : 'g');
  /**
   * @type {number}
   */
  this.PositionP = gl.getAttribLocation(
      program, goog.DEBUG ? 'PositionP' : 'j');
  /**
   * @type {number}
   */
  this.Position0 = gl.getAttribLocation(
      program, goog.DEBUG ? 'Position0' : 'k');
  /**
   * @type {number}
   */
  this.PositionN = gl.getAttribLocation(
      program, goog.DEBUG ? 'PositionN' : 'l');
  /**
   * @type {number}
   */
  this.Control = gl.getAttribLocation(
      program, goog.DEBUG ? 'Control' : 'm');
  /**
   * @type {number}
   */
  this.Style = gl.getAttribLocation(
      program, goog.DEBUG ? 'Style' : 'n');
};
/**
 * Generates a source preamble from the expressions in JSCONST
 * directives.
 * We have the rendering context passed in to allow querying
 * extensions and context attributes.
 *
 * @private
 * @param {WebGLRenderingContext} gl GL.
 * @return {string} Shader source preamble.
 */
ol.renderer.replay.webgl.geom.LineStringsRenderShader.sourcePreamble_ = function(gl) {
  return ('' +
      'const float ' +
        (goog.DEBUG ? 'CTRL_LINE_CENTER' : 'CTRL_LINE_CENTER') +
        ' = float(' + (ol.renderer.replay.webgl.geom.LineStringsBatcher.SurfaceFlags.CENTER.toFixed(1)) + ');' +
      'const float ' +
        (goog.DEBUG ? 'CTRL_TERMINAL' : 'CTRL_TERMINAL') +
        ' = float(' + (ol.renderer.replay.webgl.geom.LineStringsBatcher.SurfaceFlags.TERMINAL.toFixed(1)) + ');' +
      'const float ' +
        (goog.DEBUG ? 'CTRL_RIGHT_EDGE' : 'CTRL_RIGHT_EDGE') +
        ' = float(' + (ol.renderer.replay.webgl.geom.LineStringsBatcher.SurfaceFlags.RIGHT.toFixed(1)) + ');' +
      'const float ' +
        (goog.DEBUG ? 'CTRL_OUTGOING_EDGE' : 'CTRL_OUTGOING_EDGE') +
        ' = float(' + (ol.renderer.replay.webgl.geom.LineStringsBatcher.SurfaceFlags.OUTGOING.toFixed(1)) + ');' +
'\n');
};
