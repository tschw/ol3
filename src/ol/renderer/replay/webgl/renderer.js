goog.provide('ol.renderer.replay.webgl.Renderer');

goog.require('goog.asserts');

goog.require('ol.renderer.ImageManager');

goog.require('ol.renderer.replay.api.Batch');
goog.require('ol.renderer.replay.api.Renderer');

goog.require('ol.renderer.replay.spi.GeometriesHandlerCtors');
goog.require('ol.renderer.replay.spi.Render');
goog.require('ol.renderer.replay.spi.Renderer');

goog.require('ol.renderer.replay.webgl.Batch');
goog.require('ol.renderer.replay.webgl.Compositor');
goog.require('ol.renderer.replay.webgl.highPrecision');

goog.require('ol.webgl.ShaderCache');
goog.require('ol.webgl.TextureCache');
goog.require('ol.webgl.shader');



/**
 * @constructor
 * @extends {ol.renderer.replay.spi.Renderer}
 *
 * @param {ol.renderer.replay.spi.GeometriesHandlerCtors} renderCtors
 * @param {WebGLRenderingContext} gl GL.
 */
ol.renderer.replay.webgl.Renderer = function(renderCtors, gl) {

  goog.base(this, renderCtors);


  /**
   * WebGL rendering context.
   *
   * @type {WebGLRenderingContext}
   */
  this.gl = gl;


  var shaderCache = new ol.webgl.ShaderCache(gl);

  /**
   * @param {function(new:ol.webgl.shader.Vertex, WebGLRenderingContext)}
   *    vertexShaderCtor
   * @param {function(new:ol.webgl.shader.Fragment, WebGLRenderingContext)}
   *    fragmentShaderCtor
   * @return {WebGLProgram}
   */
  this.createGlProgram = shaderCache.getProgram.bind(shaderCache);

  /**
   * @type {ol.webgl.TextureCache}
   * @private
   */
  this.textureCache_ = new ol.webgl.TextureCache(gl, 64);

  /**
   * @type {ol.renderer.replay.webgl.Compositor}
   * @private
   */
  this.compositor_ = new ol.renderer.replay.webgl.Compositor(gl, shaderCache);

  /**
   * FIXME Remove this hack to render to a custom framebuffer (it breaks upon
   * context loss)
   * @type {WebGLFramebuffer}
   * @private
   */
  this.outputFramebuffer_ = /** @type {WebGLFramebuffer} */ (
      gl.getParameter(goog.webgl.FRAMEBUFFER_BINDING));

  this.compositor_.clear(0.5, 0.5, 0.5);

  /**
   * @type {boolean}
   * @private
   */
  this.layerReady_ = false;

  var params = this.parameters;
  params[ol.renderer.replay.webgl.Renderer.
      ExtraParameterIndex.NDC_PIXEL_SIZE] = new Array(2);
  params[ol.renderer.replay.webgl.Renderer.
      ExtraParameterIndex.RTE_COORDINATE_TRANSFORM] = new Array(16);
  params[ol.renderer.replay.webgl.Renderer.
      ExtraParameterIndex.RTE_PRETRANSLATION] = new Array(6);

};
goog.inherits(
    ol.renderer.replay.webgl.Renderer,
    ol.renderer.replay.spi.Renderer);


/**
 * ParameterVector indices for additional parameter values that are
 * generated by preprocessing the (public) input parameters for the
 * use from within WebGL.
 *
 * @enum {number}
 */
ol.renderer.replay.webgl.Renderer.ExtraParameterIndex = {

  NDC_PIXEL_SIZE: 100,
  RTE_COORDINATE_TRANSFORM: 101,
  RTE_PRETRANSLATION: 102,
  RECIPROCAL_IMAGE_INPUT_GAMMA: 103,
  RECIPROCAL_COLOR_INPUT_GAMMA: 104
};


/**
 * @param {WebGLProgram} program
 */
ol.renderer.replay.webgl.Renderer.prototype.setProgram =
    function(program) {

  if (program !== this.currentProgram_) {
    this.gl.useProgram(program);
    this.currentProgram_ = program;
  }
};


/**
 * @type {WebGLProgram}
 * @private
 */
ol.renderer.replay.webgl.Renderer.prototype.currentProgram_ = null;


/**
 * Called before rendering to ensure batch can be rendered.
 *
 * @param {ol.renderer.replay.webgl.Batch} batch
 * @private
 */
ol.renderer.replay.webgl.Renderer.prototype.prepareBatch_ = function(batch) {

  var gl = this.gl;

  var remap = ol.renderer.ImageManager.
      getInstance().requireImageSet(batch.imageSet), offs, last;
  if (! goog.isNull(remap)) {
    var vertices = batch.vertices, remapped;

    var i, e;
    for (offs = batch.texRefOffset / 4, last = vertices.length - 1;
        offs <= last && ! (vertices[offs] in remap); ++offs) {
      // empty, just seek to first affected index
    }
    for (i = offs, e = last; i <= e; ++i) {
      remapped = remap[vertices[i]];
      if (goog.isDef(remapped)) {
        vertices[i] = remapped;
        last = i;
      }
    }
  }

  if (! goog.isNull(batch.indices)) {
    if (! goog.isNull(batch.indexBuffer) && gl.isBuffer(batch.indexBuffer)) {
      gl.bindBuffer(goog.webgl.ELEMENT_ARRAY_BUFFER, batch.indexBuffer);
    } else {
      batch.indexBuffer = this.createGlBuffer_(
          goog.webgl.ELEMENT_ARRAY_BUFFER, batch.indices);
    }
  }

  if (! goog.isNull(batch.vertexBuffer) && gl.isBuffer(batch.vertexBuffer)) {
    gl.bindBuffer(goog.webgl.ARRAY_BUFFER, batch.vertexBuffer);

    if (! goog.isNull(remap)) {
      goog.asserts.assert(goog.isDef(offs) && goog.isDef(last));

      gl.bufferSubData(
          goog.webgl.ARRAY_BUFFER, offs * 4,
          batch.vertices.subarray(offs, last + 1));
    }
  } else {
    batch.vertexBuffer = this.createGlBuffer_(
        goog.webgl.ARRAY_BUFFER, batch.vertices);
  }
};


/**
 * Called from within 'render' when one or more parameters have been
 * changed to compute preprocessed extra values.
 *
 * @private
 */
ol.renderer.replay.spi.Renderer.prototype.prepareParameters_ =
    function() {

  var params = this.parameters;

  var ndcPixel = params[ol.renderer.replay.
      webgl.Renderer.ExtraParameterIndex.NDC_PIXEL_SIZE],
      resolution = params[ol.renderer.replay.
      api.Renderer.ParameterIndex.RESOLUTION];
  ndcPixel[0] = 2 / resolution[0];
  ndcPixel[1] = 2 / resolution[1];

  ol.renderer.replay.webgl.highPrecision.detachTranslation(
      /** @type {Array.<number>} */ (params[ol.renderer.replay.
          webgl.Renderer.ExtraParameterIndex.RTE_PRETRANSLATION]),
      /** @type {Array.<number>} */ (params[ol.renderer.replay.
          webgl.Renderer.ExtraParameterIndex.RTE_COORDINATE_TRANSFORM]),
      /** @type {Array.<number>} */ (params[ol.renderer.replay.
          api.Renderer.ParameterIndex.COORDINATE_TRANSFORM]));

  params[ol.renderer.replay.
      webgl.Renderer.ExtraParameterIndex.RECIPROCAL_IMAGE_INPUT_GAMMA] =
      1 / params[ol.renderer.replay.
          api.Renderer.ParameterIndex.HINT_IMAGE_INPUT_GAMMA];

  params[ol.renderer.replay.
      webgl.Renderer.ExtraParameterIndex.RECIPROCAL_COLOR_INPUT_GAMMA] =
      1 / params[ol.renderer.replay.
          api.Renderer.ParameterIndex.HINT_COLOR_INPUT_GAMMA];
};


/**
 * @override
 */
ol.renderer.replay.webgl.Renderer.prototype.render =
    function(batch) {


  batch = /** @type {ol.renderer.replay.webgl.Batch} */ (batch);

  if (this.gl.isContextLost()) {
    return;
  }

  this.prepareBatch_(batch);

  if (! this.layerReady_) {
    this.beginLayer();
  }

  /**
   * @type {number}
   */
  this.indexBufferOffset = 0;

  /**
   * @type {number}
   */
  this.texRefReadOffset = batch.texRefOffset;

  if (this.parametersChanged) {
    this.prepareParameters_();
    // Changed flag is unset in the 'configure' method of the Render base
    // class.
  }

  goog.base(this, 'render', batch);
};


/**
 * @private
 */
ol.renderer.replay.webgl.Renderer.prototype.resetState_ = function() {

  if (! goog.isNull(this.currentRender)) {
    this.currentRender.configure(null, 0);
    this.currentRender = null;
  }

  this.currentProgram_ = null;
};


/**
 * @inheritDoc
 */
ol.renderer.replay.webgl.Renderer.prototype.beginLayer =
    function(opt_opacity) {

  this.resetState_();
  this.compositor_.beginPass(opt_opacity);
  this.layerReady_ = true;
};


/**
 * @override
 */
ol.renderer.replay.webgl.Renderer.prototype.flush = function() {

  this.resetState_();
  this.compositor_.present(/** @type {number} */ (this.parameters[
      ol.renderer.replay.api.Renderer.ParameterIndex.HINT_OUTPUT_GAMMA]),
      this.outputFramebuffer_);
  this.compositor_.clear(0.5, 0.5, 0.5);
  this.layerReady_ = false;
};


/**
 * @inheritDoc
 */
ol.renderer.replay.webgl.Renderer.prototype.unloadBatch =
    function(batch) {

  batch = /** @type {ol.renderer.replay.webgl.Batch} */ (batch);

  var gl = this.gl;

  if (! goog.isNull(batch.vertexBuffer)) {
    gl.deleteBuffer(batch.vertexBuffer);
    batch.vertexBuffer = null;
  }

  if (! goog.isNull(batch.indexBuffer)) {
    gl.deleteBuffer(batch.indexBuffer);
    batch.indexBuffer = null;
  }
};


/**
 * Create a WebGLBuffer.
 *
 * @param {number} target GL target descriptor.
 * @param {Float32Array|Uint16Array} data Data as typed array.
 * @return {WebGLBuffer} GL buffer object.
 * @private
 */
ol.renderer.replay.webgl.Renderer.prototype.createGlBuffer_ =
    function(target, data) {

  var gl = this.gl;
  var result = gl.createBuffer();
  gl.bindBuffer(target, result);
  gl.bufferData(target, data, goog.webgl.STATIC_DRAW);
  return result;
};


/**
 * Set uniforms common parameter values.
 *
 * @param {WebGLUniformLocation} transform 4x4-Matrix.
 * @param {WebGLUniformLocation} pretranslation 4-Vector.
 * @param {WebGLUniformLocation=} opt_pixelScale 2-Vector.
 */
ol.renderer.replay.webgl.Renderer.prototype.setCommonUniforms =
    function(transform, pretranslation, opt_pixelScale) {

  var gl = this.gl, params = this.parameters;

  gl.uniformMatrix4fv(transform, false,
      /** @type {Array.<number>} */ (params[ol.renderer.replay.
          webgl.Renderer.ExtraParameterIndex.RTE_COORDINATE_TRANSFORM]));

  var tmp = /** @type {Array.<number>} */ (params[ol.renderer.replay.
          webgl.Renderer.ExtraParameterIndex.RTE_PRETRANSLATION]);
  gl.uniform4f(pretranslation, tmp[0], tmp[1], tmp[3], tmp[4]);

  if (goog.isDefAndNotNull(opt_pixelScale)) {

    gl.uniform2fv(opt_pixelScale,
        /** @type {Array.<number>} */ (params[ol.renderer.replay.
            webgl.Renderer.ExtraParameterIndex.NDC_PIXEL_SIZE]));
  }
};


/**
 * Bind atlas textures from the image manager to consecutive texture units
 * and corresponding sampler uniforms.
 *
 * @param {...WebGLUniformLocation} var_args Sampler uniforms.
 */
ol.renderer.replay.webgl.Renderer.prototype.configureAtlasTextures =
    function(var_args) {

  var gl = this.gl, i = 0, e,
      textures = ol.renderer.ImageManager.getInstance().getAtlasImages();

  this.textureCache_.protectFromHere();

  // Reverse iteration to be a good neighbor and end with TEXTURE0 active

  // Unbind unused texture units
  for (i = arguments.length, e = textures.length; --i >= e;) {
    gl.activeTexture(goog.webgl.TEXTURE0 + i);
    this.textureCache_.unbindTexture();
  }
  // Bind used texture units
  for (i = textures.length; --i >= 0;) {
    gl.activeTexture(goog.webgl.TEXTURE0 + i);
    this.textureCache_.bindTexture(textures[0]);
  }
  // Set sampler uniforms
  for (i = arguments.length; --i >= 0;) {
    var uniformLocation = arguments[i];
    gl.uniform1i(uniformLocation, i);

    goog.asserts.assert(
        i >= textures.length || ! goog.isNull(uniformLocation),
        'Render ignores nonempty texture slot');
  }
};
